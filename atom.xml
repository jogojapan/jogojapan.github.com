<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[stringalgo::sufex]]></title>
  <link href="http://jogojapan.github.com/atom.xml" rel="self"/>
  <link href="http://jogojapan.github.com/"/>
  <updated>2013-01-07T14:30:56+09:00</updated>
  <id>http://jogojapan.github.com/</id>
  <author>
    <name><![CDATA[jogojapan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making trigrams]]></title>
    <link href="http://jogojapan.github.com/blog/2012/12/21/making-trigrams/"/>
    <updated>2012-12-21T19:57:00+09:00</updated>
    <id>http://jogojapan.github.com/blog/2012/12/21/making-trigrams</id>
    <content type="html"><![CDATA[<p>Today I want to quickly introduce the first building block of the
suffix array library that is part of Sufex: Trigram generation.</p>

<p>One of the most important modern algorithms for suffix array
generation is the <strong>DC algorithm</strong>, also known as <strong>Skew algorithm</strong>
(<a href="http://link.springer.com/chapter/10.1007%2F3-540-45061-0_73?LI=true">DOI
10.1007/3-540-45061-0_73</a>),
discovered by Juha Kärkkäinen and Peter Sanders in 2003.</p>

<p>I won&#8217;t describe the algorithm here, however, its first step is to
generate trigrams from the input text and sorting them
lexicographically. The algorithm does not generate <em>all</em> trigrams, but
only those located at positions not divisible by three, i.e. positions
<code>p</code> such that <code>p % 3</code> is <code>1</code> or <code>2</code>. The module of Sufex that performs
this step is
<a href="https://github.com/jogojapan/sufex/blob/master/src/sux/trigram.hpp"><code>sux/trigram.hpp</code></a>.</p>

<h2>Trigram implementation</h2>

<p>In later steps of the algorithm, Sufex needs to access the trigrams at
the place where they are found in the input text. Therefore, the
trigram implementation must include either the relative position of
the trigram within the text, or a pointer to the character location.</p>

<p>During the sorting step, lots of trigrams must be compared to each
other, which requires access only to the three characters that belong
to each trigram. For better cache-efficiency, it is therefore useful
to actually store these three characters inside the trigram
representation, along with the position information or
pointer. However, this isn&#8217;t <em>necessary</em>.</p>

<p>Sufex provides <strong>three different implementations</strong> of trigrams, and
the sorting algorithms are designed to work with any of them. The
three types are specified by the values of an enumeration called
<code>sux::TGImpl</code>, while the actual data type for trigrams is defined as a
struct called <code>sux::TrigramImpl</code>:</p>

<figure class='code'><figcaption><span>Trigram implementations  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">namespace</span> <span class="n">sux</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/* Three implementations of trigrams: */</span>
</span><span class='line'>  <span class="k">enum</span> <span class="k">class</span> <span class="nc">TGImpl</span> <span class="p">{</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">arraytuple</span><span class="p">,</span> <span class="n">pointer</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Data type for the trigram implementation: */</span>
</span><span class='line'>  <span class="k">template</span> <span class="o">&lt;</span><span class="n">TGImpl</span> <span class="n">tgimpl</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Char</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pos</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">TrigramImpl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Char</code> and <code>Pos</code> represent data types for individual characters and
position/offset information, respectively. Hence, when using <code>char</code>
for characters and <code>long</code> for positions, a single trigram can be
stored in one of three data structures shown below:</p>

<figure class='code'><figcaption><span>Trigram implementations  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">sux</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* Using a single pointer to represent the trigram: */</span>
</span><span class='line'><span class="n">TrigramImpl</span><span class="o">&lt;</span><span class="n">TGImpl</span><span class="o">::</span><span class="n">pointer</span><span class="p">,</span><span class="kt">char</span><span class="p">,</span><span class="kt">long</span><span class="o">&gt;</span>    <span class="n">trigram1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* Using std::tuple&lt;long,char,char,char&gt; to encode position</span>
</span><span class='line'><span class="cm">   and contents of the trigram: */</span>
</span><span class='line'><span class="n">TrigramImpl</span><span class="o">&lt;</span><span class="n">TGImpl</span><span class="o">::</span><span class="n">tuple</span><span class="p">,</span><span class="kt">char</span><span class="p">,</span><span class="kt">long</span><span class="o">&gt;</span>      <span class="n">trigram2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* Using std::tuple&lt;long,std::array&lt;char,3&gt;&gt; to encode position</span>
</span><span class='line'><span class="cm">   and contents of the trigram: */</span>
</span><span class='line'><span class="n">TrigramImpl</span><span class="o">&lt;</span><span class="n">TGImpl</span><span class="o">::</span><span class="n">arraytuple</span><span class="p">,</span><span class="kt">char</span><span class="p">,</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">trigram3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first one, <code>TGImpl::pointer</code>, consists of a single pointer <code>char
*</code> only and is therefore small in memory but relatively slow during
sorting.</p>

<p>The second one, <code>TGImpl::tuple</code>, uses a <code>std::tuple</code> to store both the
relative position of the trigram and its contents. This is the fastest
implementation during sorting.</p>

<p>The third one, <code>TGImpl::arraytuple</code>, uses a combination of
<code>std::tuple</code> and <code>std::array</code> to store the relative position and the
contents of the trigram. It is a little slower than <code>TGImpl::tuple</code>,
but can more easily be extended to store n-grams with higher n, which
may become important in alternative implementations of suffix array
construction.</p>

<h2>Generating trigrams</h2>

<p>The DC algorithm involves creating an array of trigrams at positions p
such that <code>p % 3 = 1,2</code>. For this, the <code>sux::TrigramMaker</code> can be
used:</p>

<figure class='code'><figcaption><span>Trigram generation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">sux</span><span class="p">;</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">input</span> <span class="p">{</span> <span class="s">&quot;abcabeabxd&quot;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Generating trigrams. */</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">trigrams</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">TrigramMaker</span><span class="o">&lt;</span><span class="n">TGImpl</span><span class="o">::</span><span class="n">tuple</span><span class="p">,</span><span class="n">string</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span><span class="n">size_t</span><span class="o">&gt;::</span><span class="n">make_23trigrams</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">input</span><span class="p">),</span><span class="n">end</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Printing them. */</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">trigram</span> <span class="o">:</span> <span class="n">trigrams</span><span class="p">)</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">triget1</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget2</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget3</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Evidently, <code>TrigramMaker</code> takes three template arguments:</p>

<ul>
<li>The trigram implementation (<code>TGImpl::tuple</code>, <code>TGImpl::arraytuple</code>
or <code>TGImpl::pointer</code>);</li>
<li>The character type (e.g. <code>char</code>)</li>
<li>The position type (e.g. <code>unsigned long</code>)</li>
</ul>


<p>It&#8217;s <code>make_23trigrams</code> function must be applied to a range of
characters specified by two iterators. The value returned is a
<code>std::vector</code> of trigrams.</p>

<p>There is a <strong>convenience function</strong> <code>sux::string_to_23trigrams()</code> that
can be used if the input is stored in a <code>std::basic_string</code>:</p>

<figure class='code'><figcaption><span>Trigram generation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">sux</span><span class="p">;</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">input</span> <span class="p">{</span> <span class="s">&quot;abcabeabxd&quot;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Generating trigrams. */</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">trigrams</span> <span class="o">=</span> <span class="n">string_to_23trigrams</span><span class="o">&lt;</span><span class="n">TGImpl</span><span class="o">::</span><span class="n">arraytuple</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Printing them. */</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">trigram</span> <span class="o">:</span> <span class="n">trigrams</span><span class="p">)</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">triget1</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget2</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget3</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>It takes only one template argument, the trigram implementation. It
defaults to <code>TGImpl::tuple</code>.</p>

<h2>Sorting trigrams</h2>

<p>Trigrams are sorted in three passes of radix sort. During the first
pass, trigrams are put into buckets according to the third character
of each trigrams. During the second pass, they are stably sorted into
buckets defined by the second character, and during the third pass
they are stably sorted into buckets defined by the first
character. Each pass can be parallelized by running several radix-sort
threads in parallel, each on a different chunk of the trigrams.</p>

<p>The implementation is encapsulated in the <code>sux::TrigramSorter</code>
template, which can be applied to any implementation of trigrams,
i.e. regardless of whether <code>TGImpl::tuple</code>, <code>TGImple::arraytuple</code> or
<code>TGImpl::pointer</code> is used, and regardless of the data types used for
characters and positions.</p>

<p>Again, there is a <strong>convenience function</strong> <code>sux::sort_23trigrams()</code>,
which takes two arguments:</p>

<ul>
<li>The trigram container (i.e. what was returned by
<code>make_23trigrams()</code>)</li>
<li>The desired number of threads (defaults to 1)</li>
</ul>


<p>Hence, the easiest way to create the 2,3-trigrams from a <code>std::string</code>
and sort them using parallel 2 threads is this:</p>

<figure class='code'><figcaption><span>Trigram generation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="k">namespace</span> <span class="n">sux</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Input. */</span>
</span><span class='line'>  <span class="n">string</span> <span class="n">input</span> <span class="p">{</span> <span class="s">&quot;abcabeabxd&quot;</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* 2,3-Trigrams. */</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">trigrams</span> <span class="o">=</span> <span class="n">string_to_23trigrams</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Trigram sorting using 2 parallel threads. */</span>
</span><span class='line'>  <span class="n">sort_23trigrams</span><span class="p">(</span><span class="n">trigrams</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Printing the results. */</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">trigram</span> <span class="o">:</span> <span class="n">trigrams</span><span class="p">)</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">triget1</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget2</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">triget3</span><span class="p">(</span><span class="n">trigram</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Running times for different trigram implementations</h2>

<p>I&#8217;ve compared running times of trigram sorting for the three
implementations of trigrams, and for two different sorting algorithms:
The radix sort described above, and <code>std::stable_sort</code>.</p>

<p>The comparison involved running each version once on a dual-core Intel
machine (2 T9300 cores, L1-cache 32KB per core, L2 cache 6144 KB for
both cores, 4 GB RAM) and measuring user time, system time and real
time in milliseconds. The results are reported in <a href="https://docs.google.com/spreadsheet/pub?key=0AqDFvV2_pwzSdHBKSWRrdWdUUzFiSnhENnFJcFljWUE&amp;output=html">this Google spreadsheet</a>.</p>

<p><img src="http://jogojapan.github.com/images/trigram-running-time.png" width="650" height="550" title="4-threads radix sort vs. 1-thread std::stable_sort" ></p>

<p><strong>Main observations</strong></p>

<ol>
<li><code>TGImpl::tuple</code> and <code>TGImpl::arraytuple</code> are equally fast, but
<code>TGImpl::pointer</code> is considerably slower. This is no surprise, as
using pointer requires derefencing it in each comparison step.</li>
<li>In <strong>one-thread mode</strong>, <code>std::stable_sort</code> is faster than my radix
sort implementation. I believe this is mainly caused by the fact that
radix sort needs to <strong>determine the alphabet</strong> and count the number of
occurrences of every character, in <em>each</em> radix pass. This is
acceptable, because during the recursive steps of suffix array
construction (not yet implemented), an integer alphabet is used, which
does not require this step.</li>
<li>In <strong>multithreading mode</strong>, radix sort is <strong>much faster in terms of
real time</strong> (yellow bars) than the built-in <code>std::stable_sort</code> (which
runs on one thread only).</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Measuring CPU time, Boost and C++11]]></title>
    <link href="http://jogojapan.github.com/blog/2012/11/25/measuring-cpu-time/"/>
    <updated>2012-11-25T19:51:00+09:00</updated>
    <id>http://jogojapan.github.com/blog/2012/11/25/measuring-cpu-time</id>
    <content type="html"><![CDATA[<p>The first set of algorithms I am going to discuss will be related to
the elementary steps of suffix array construction, in particular
<strong>trigram sorting</strong> and <strong>lexicographic renaming</strong>, and I will start a
series of blog posts about this soon.</p>

<p>However, to be able to compare various implementations of those
algorithms, it&#8217;s important to use a clearly defined and consistent
approach to <strong>measuring time</strong>. In addition to using Linux tools like
<a href="http://linux.die.net/man/1/time">time</a> and
<a href="http://linux.die.net/man/1/ps">ps</a>, I would like to be able to build
precise time-measurements into the C++ code, so as to be able to
measure precisely what amount of time is spent in which part of the
program.</p>

<h2>Two types of time</h2>

<p>There are two types of time I need to be able to measure:</p>

<ul>
<li><p><strong>Real time</strong> (aka <a href="http://en.wikipedia.org/wiki/Wall_clock_time">wall clock time</a>):
The actual time that passed between a predefined starting point and
an end point, measured in seconds.</p></li>
<li><p><strong>CPU time</strong> (for example described
<a href="http://en.wikipedia.org/wiki/CPU_time">here</a>): The number of ticks
(of the CPU clock) that passed <em>while the CPU was busy performing
the process being measured</em>. This does not include time spent
during non-CPU related activities, such as IO, and it does not
include time the CPU spent performing other processes. While CPU
time is measured in clock ticks, it is usually converted to seconds
by dividing it by the <em>number of clock ticks per second</em>, which on
Linux you can retrieve using a system call:
<code>::sysconf(_SC_CLK_TCK)</code>.</p></li>
</ul>


<p>There is a third type of time that will be important:
<strong>Thread-specific CPU time</strong>, but I won&#8217;t talk about this in the
current post.</p>

<h2>Library support</h2>

<h3>C++11</h3>

<p>C++11 offers a convenient method to measure real time, <strong>but not CPU
time</strong>, through the <a href="http://en.cppreference.com/w/cpp/chrono#chrono_library"><code>&lt;chrono&gt;</code> library</a>.
Specifically, there are three functions that return a representation
of the <em>current point in time</em>:</p>

<pre><code>std::chrono::system_clock::now()  // System clock, may be modified by the OS while
                                  // the process is running, e.g. when switching
                                  // to daylight-saving time

std::chrono::steady_clock::now() // Steady clock, guaranteed to run steadily from the
                                 // moment the process is started to its end

std::chrono::high_resolution_clock::now() // Steady clock with high resolution
</code></pre>

<p>The existence of all three is required by the Standard, so they can be
used regardless of the platform the code is written for. The
<code>std::time_point</code> object returned by these functions can easily be
used to compute the time difference between two time points (using
<code>operator-</code>), and that difference can be readily converted to any unit
of choice (using <code>std::chrono::duration_cast</code>):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'><span class="cm">/* .. perform work .. */</span>
</span><span class='line'><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">elapsed_seconds</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="o">&gt;</span>
</span><span class='line'>                         <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Elapsed time: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed_seconds</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; seconds&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The benefits of this are <strong>portability</strong> and <strong>convenience</strong>, but
unfortunately this can only be used to measure real time, not CPU
time.</p>

<h3>Boost</h3>

<p>The Boost library provides a similarly designed framework with the
same clocks for real time (in fact, of course, <code>std::chrono</code> was
designed using <code>boost:chrono</code> as a model). In addition, there are
three more clocks:</p>

<pre><code>boost::chrono::process_user_cpu_clock::now()   // User CPU time since the process
                                               // started (including user CPU time
                                               // of child processes)

boost::chrono::process_system_cpu_clock::now() // System CPU time since the process
                                               // started (including user CPU time
                                               // of child processes)

boost::chrono::process_real_cpu_clock::now()   // Wall-clock time, measured using the
                                               // CPU clock of the process
</code></pre>

<p>Boost also provides a <strong>combined clock</strong>,
<code>boost::chrono::process_cpu_clock</code>, which gives access to time points
for all three types of CPU clock. This is also <strong>portable</strong> and
<strong>convenient</strong>, but I had a <strong>number of problems</strong> with this:</p>

<h3>Problems with Boost</h3>

<ul>
<li><p><code>boost::chrono::time_point</code> objects returned by the Boost clocks are
<strong>not compatible with <code>std::time_point</code></strong>, which I find makes the code
<em>look confusing when you use both the time points and duration object
</em>from <code>boost::chrono</code> and <code>std::chrono</code> in parallel.</p></li>
<li><p>The Boost CPU clocks measure time in terms of CPU ticks and
immediately convert this to nanoseconds. The problem with this on
typical Linux installations is that a clock tick is a relatively
long unit of time; on my machine it is 10 milliseconds in
length. This means that even when you measure a relatively short
process, e.g. 2 seconds CPU time, the internal representation of
this used by the Boost library will be 2 billion nanoseconds. The
data type used to store the value is <code>std::clock_t</code>, which on 32-bit
Linux is typically a signed 32-bit integer, which means 2 billion is
very close to overflow. As a result, you get <strong>overflows and negative
run times even for processes of just a few seconds (even sub-second
if several threads are involved).</strong></p></li>
<li><p>There doesn&#8217;t seem to be any <strong>pretty-print</strong> function, nor
<strong>unit-converters</strong> for the combined user/system/real clock Boost
provides. I am usually interested in measuring all three of them, but
<code>boost::chrono::process_cpu_clock::now()</code> returns time point objects
that are triples, and none of the convenient duration-casts and no
pretty-printing seems to be available for them.</p></li>
</ul>


<h2>New implementation: <code>rlxutil::combined_clock</code></h2>

<p>What I wanted is a clock that returns time points which include user,
system and real time, where real time is measured using the
high-resolution clock from <code>std</code>, and user and system time are
measured using a platform-specific implementation, but using
<code>std::chrono::time_point</code> objects (and <code>std::chrono::duration</code> objects
when the difference between two time points is calculated).</p>

<p>I ended up implementing this myself. It now exists in the form of the
<a href="https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp">util/proctime.hpp</a>
header within the sufex repository. The main class is
<code>rlxutil::combined_clock&lt;Precision&gt;</code>. Note the template parameter
<code>Precision</code>: You can use any of the <code>std::ratio</code> types defined in
<code>&lt;ratio&gt;</code>, e.g. <code>std::micro</code> or <code>std::nano</code> as argument. This will
determine the internal representation of the time points: As
nanoseconds when <code>std::nano</code> is used, as microseconds when
<code>std::micro</code> is used, and so on.</p>

<h3>Usage</h3>

<p>Here is an example of how it&#8217;s used:</p>

<figure class='code'><figcaption><span>combined_clock usage </span><a href='https://github.com/jogojapan/sufex/blob/master/src/util/app/combined_clock.cpp'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &quot;util/proctime.hpp&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;ratio&gt;</span>
</span><span class='line'><span class="cp">#include &lt;chrono&gt;</span>
</span><span class='line'><span class="cp">#include &lt;thread&gt;</span>
</span><span class='line'><span class="cp">#include &lt;utility&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">millisec</span>   <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">;</span>
</span><span class='line'>  <span class="k">using</span> <span class="n">clock_type</span> <span class="o">=</span> <span class="n">rlxutil</span><span class="o">::</span><span class="n">combined_clock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">micro</span><span class="o">&gt;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">auto</span> <span class="n">tp1</span> <span class="o">=</span> <span class="n">clock_type</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Perform some random calculations. */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">step1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">step2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50000000</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">step3</span> <span class="o">=</span> <span class="n">step1</span> <span class="o">+</span> <span class="n">step2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">step1</span><span class="p">,</span><span class="n">step2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">step2</span><span class="p">,</span><span class="n">step3</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* Sleep for a while (this adds to real time, but not CPU time). */</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">millisec</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">auto</span> <span class="n">tp2</span> <span class="o">=</span> <span class="n">clock_type</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Elapsed time: &quot;</span>
</span><span class='line'>            <span class="o">&lt;&lt;</span> <span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">millisec</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tp2</span> <span class="o">-</span> <span class="n">tp1</span><span class="p">)</span>
</span><span class='line'>            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Output generated by this program:</p>

<pre><code>Elapsed time: [user 40, system 0, real 1070 millisec]
</code></pre>

<h3>Implementation</h3>

<p>The static <code>now()</code> function generates a time point by calling
<code>::times</code> to retrieve user and system time, as well as calling
<code>std::chrono::high_resolution_clock::now()</code> to retrieve real time. The
user and system times are then converted from ticks to the unit
determined by <code>Precision</code>. This requires a tick factor, which depends
on the number of ticks per second <code>::sysconf(SC_CLK_TCK)</code> and
<code>Precision</code>:</p>

<figure class='code'><figcaption><span>rlxutil::tickfactor<Precision> </span><a href='https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cm">/* Code related to log messages removed. */</span>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Precision</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">intmax_t</span> <span class="n">tickfactor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">intmax_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="o">::</span><span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_CLK_TCK</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">Precision</span><span class="o">::</span><span class="n">den</span><span class="p">)</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">result</span> <span class="o">=</span> <span class="n">Precision</span><span class="o">::</span><span class="n">den</span> <span class="o">/</span> <span class="o">::</span><span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_CLK_TCK</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The key differences to the Boost implementation are:</p>

<ul>
<li><p>We use <code>std::intmax_t</code> instead of <code>clock_t</code>, which on typical
systems (including 32-bit systems) provides us with 64 bits to store
the internal representation of the time point;</p></li>
<li><p>We use the unit suggested by <code>Precision</code> rather than defaulting to
nanoseconds.</p></li>
</ul>


<p>Both help avoid overflows and spurious negative duration
results. Specifically, the <code>Precision</code> parameter can be used by the
caller to obtain a representation that suits the purpose: For
measuring very short-lived processes, <code>std::micro</code> may be best, while
longer processes can be measured using <code>std::milli</code>.</p>

<p>The clock data type itself has been implemented following the
requirements by the C++ Standard.</p>

<figure class='code'><figcaption><span>rlxutil::combined_clock<Precision> interface </span><a href='https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Precision</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">combined_clock</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">__is_ratio</span><span class="o">&lt;</span><span class="n">Precision</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span><span class='line'>      <span class="s">&quot;Precision must be a std::ratio&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Precision</span><span class="o">&gt;</span>                     <span class="n">rep</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">Precision</span>                                         <span class="n">period</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">rep</span><span class="p">,</span><span class="n">period</span><span class="o">&gt;</span>                 <span class="n">duration</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">combined_clock</span><span class="p">,</span><span class="n">duration</span><span class="o">&gt;</span>  <span class="n">time_point</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="n">constexpr</span> <span class="kt">bool</span> <span class="n">is_steady</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">static</span> <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The internal representation of a time point, <code>combined_clock::rep</code> is
a tuple nested into a struct:</p>

<figure class='code'><figcaption><span>rlxutil::rep_combined_clock<Precision> definition </span><a href='https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Precision</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">rep_combined_clock</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">Precision</span>                             <span class="n">precision</span><span class="p">;</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">intmax_t</span><span class="p">,</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">intmax_t</span><span class="p">,</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">rep</span><span class="o">&gt;</span>  <span class="n">rep</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">rep</span> <span class="n">_d</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The struct wrapper was necessary to distinguish it clearly from tuple
types that originate somewhere else: The <code>operator-</code> and
<code>duration_cast</code> function used to calculate elapsed time only accept
the struct defined above, not general tuples.</p>

<p>The functions below were implemented inside namespace <code>std</code> to enable
pretty-printing, elapsed-time calculation and duration-casts:</p>

<figure class='code'><figcaption><span>Convenience functions </span><a href='https://github.com/jogojapan/sufex/blob/master/src/util/proctime.hpp'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Precision</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Period</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">strm</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Precision</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Period</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dur</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pr</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Per</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">constexpr</span> <span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Per</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">operator</span><span class="o">-</span><span class="p">(</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">time_point</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Per</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">time_point</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Per</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ToDur</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pr</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Period</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">constexpr</span> <span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span><span class="k">typename</span> <span class="n">ToDur</span><span class="o">::</span><span class="n">period</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">duration_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">duration</span><span class="o">&lt;</span><span class="n">rlxutil</span><span class="o">::</span><span class="n">rep_combined_clock</span><span class="o">&lt;</span><span class="n">Pr</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Period</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dur</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ultimate Goal: Better Natural Language Processing]]></title>
    <link href="http://jogojapan.github.com/blog/2012/11/12/ultimate-goal-dissecting-natural-language/"/>
    <updated>2012-11-12T00:02:00+09:00</updated>
    <id>http://jogojapan.github.com/blog/2012/11/12/ultimate-goal-dissecting-natural-language</id>
    <content type="html"><![CDATA[<p>Natural language processing has become big. Almost every university
employs at least a few researchers specializing in it, almost every
major internet company hires NLP specialists to help analyse the
natural language part of &#8220;big data&#8221;, and hundreds of workshops and
conferences are held every year.</p>

<p>Its methods have changed, too: Several decades ago, ideas based on
mathematical logic dominated the <em>semantic analysis</em>, and ideas based
on phrase structure grammars dominated the <em>syntactic
analysis</em>. However, for the past ten years or so, statistical machine
learning and large-scale corpus studies have dominated the field.</p>

<p>This blog is dedicated to its own variety of natural language
processing. Its principles are different from those of today&#8217;s
mainstream NLP, and they are different from most (though probably not
all) of the NLP and computational linguistics of the past. The key
elements are:</p>

<ul>
<li><p><strong>Lexeme-specific rules:</strong> The syntax of a language is described
using rules, but there are far more rules than in traditional
phrase structure grammars, and there are many rules that apply to a
single lexeme only.</p></li>
<li><p><strong>Structural analogy:</strong> Sentence structures that cannot be analysed
using existing rules are analysed in the same way as sentences that
are structurally <em>similar</em> or <em>analogous</em>. This notion of
structural analogy will be defined in terms of predetermined
transformation rules as well as approximate (fuzzy) matching
against corpora of example sentences.</p></li>
<li><p><strong>Interactive refinement:</strong> The formal description of the grammar
(lexeme-specific rules, transformation rules and other elements) is
created iteratively by testing intermediate stages against large
corpora. To this end, a specialized corpus query system (CQS) is
used.</p></li>
</ul>


<p>A lot of this is still very unclear. I started my activities by
creating a CQS, and doing this involved a significant amount of
research into the architecture of search engines, and the data
structures and algorithms they use.</p>

<p>This blog is going to describe my approach to NLP as it evolves, and
it will do so in great detail. I&#8217;ll start with the CQS, which I
decided to re-implement from scratch. I&#8217;ll blog about my choice of
algorithms and implementation strategies, as well as specific &ndash;
and sometimes very minor &ndash; programming techniques as I rebuild
the CQS. This alone will take many months, perhaps more than a year.</p>

<p>I have also started to work on the definition of the lexeme-specific
rule framework and prototypical designs for a parser. Posts related to
this will start to appear in the blog soon, perhaps in a few weeks or
months from now. Over time, the focus will gradually shift from string
algorithms and implementation strategies towards grammar description
and linguistics, and the blog title, <em>Algorithms on Strings</em>, will be
increasingly</p>

<p>My programming language is C++ (C++11 and a lot of Boost), and the
operating system is Linux. The hardware I use includes both
Intel-based PCs and large Xeon-based servers with tens of CPU cores
and 1 TB of RAM.</p>
]]></content>
  </entry>
  
</feed>
